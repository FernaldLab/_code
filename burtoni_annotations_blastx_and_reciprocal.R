###
rm(list=ls());
options(stringsAsFactors=F);
setwd('~/Documents/_Burtoni_annotations/');
library(biomaRt);

#############################################################
### load files
#############################################################

# this should be file generated from parseBestHitBlastxResultsWithComments.py
parsedBlastxResults = 'H_burtoni_rna_blastx_FISH_ENS_top1.transcriptsAndHitsByGenes';

# this should be raw blastx results but with comment lines removed
reciprocalBlastpResults = 'H_burtoni_rna_blastx_FISH_ENS_top1_reciprocalBackFrom_Drer_Olat_Onil_Trub_ENS_pep_noComments';

# this should be file generated by parseFeatureFileToLookup.py
AburtoniLookup = 'ref_AstBur1.0_scaffolds.clean.translate.final.gff3.lookup';

# read in parsed burtoni blastx results
x = read.table(parsedBlastxResults, header=F, sep='\t', colClasses='character', quote='');
# split to make list where elements are matrices with blastx results of transcripts for a gene   
xs = split(x, x[,1]);

# read in reciprocal blastp results 
rx = read.table(reciprocalBlastpResults, header=F, sep='\t', colClasses='character', quote='');
# split to make list where elements are matrices with blastx results
rxs = split(rx, rx[,1]);

# read in lookup table to translate between burtoni protein, rna, and gene ids
ablookup = read.table(AburtoniLookup, header=T, sep='\t', fill=T, colClasses='character');

#############################################################
### compare results from reciprocal blastp to original blastx
#############################################################

# get all unique hits from original blastx
oHits = unique(grep('^ENS', unlist(xs), value=T));

# get subset of these hits that are not in reciprocal blastp results
if (length(oHits) > length(rxs)) {
	dHits = setdiff(oHits, names(rxs));
} else if (length(oHits) < length(rxs)) {
	dHits = setdiff(names(rxs), oHits);
} else if (all(sort(oHits) == sort(names(rxs)))) {
	print('all the same');
} else {
	print('same length, but some mismatches');
}

# see where they were in original blastx results
xs[names(xs) %in% x[match(dHits, x[,3]), 1]];

# function source code below
checkRecip = .checkReciprocalBlastAgainstOriginal(recipList=rxs, ablookup=ablookup, abBlastxList=xs, verbose=1000);
failRecip = subset(checkRecip, recipMatch==FALSE);
passRecip = subset(checkRecip, recipMatch==TRUE);

failGenes = unique(failRecip$gene);
for (g in 1:10) {
	print(subset(checkRecip, checkRecip$gene==failGenes[g]))
}; rm(g);


checkRecipByLOC = split(checkRecip, checkRecip$gene);
counter = 0
for (g in checkRecipByLOC) {
	if (nrow(g) > 1) { print(g); counter=counter+1 }
}; rm(g);

#######

#speciesLookup = cbind(c('drerio','olatipes','oniloticus','trubripes'), c('DAR','ORL','ONI','TRU'));

speciesMarts = list(DAR=useMart(biomart='ensembl', dataset='drerio_gene_ensembl'),
					ORL=useMart(biomart='ensembl', dataset='olatipes_gene_ensembl'),
					ONI=useMart(biomart='ensembl', dataset='oniloticus_gene_ensembl'),
					TRU=useMart(biomart='ensembl', dataset='trubripes_gene_ensembl')
					);
attributes = c('ensembl_peptide_id','ensembl_gene_id','description','external_gene_name','hsapiens_homolog_ensembl_gene');
filters = 'ensembl_peptide_id';



#######



hsENS = .convertMultiSpeciesENStoHuman(rownames(passRecip), speciesMarts, attributes, filters, 1);

passRecipHsENS = cbind(passRecip, hsENS=rep(NA,nrow(passRecip)));
for (s in 1:length(hsENS)) {
	print(names(hsENS)[s])
	for (g in 1:length(hsENS[[s]])) {
		this = hsENS[[s]][[g]];
		if (length(unique(this$ensembl_peptide_id)) > 1) {
			print(this)
		}
		row = which(rownames(passRecipHsENS) == unique(this$ensembl_peptide_id));
		passRecipHsENS$hsENS[row] = paste(this$hsapiens_homolog_ensembl_gene, collapse=',');
	}
}; rm(s,g,this,row);


passRecipHsENSbyLOC = split(passRecipHsENS, passRecipHsENS$gene);
counter = 0
for (g in passRecipHsENSbyLOC) {
	if (g$hsENS != '') { counter=counter+1 }
}; rm(g);

#############################################################
### functions
#############################################################

.checkReciprocalBlastAgainstOriginal = function (recipList, ablookup, abBlastxList, verbose=NULL) {
	# make empty data frame
	# each row is an original blastx hit that also hit a burtoni gene in reciprocal blastp
	# columns are burtoni identifiers associated with burtoni protein id from blastp
	# 	and one T/F column indicating whether blastx-blastp results agreed
	checkRecip = as.data.frame(matrix(nrow=length(recipList), 
									  ncol=ncol(ablookup)+2, 
									  dimnames=list(names(recipList), c(names(ablookup), 'recipMatch', 'oBlastxHits'))
									  )
							   );
	# loop through reciprocal blastp results to build checkRecip data frame
	for (id in 1:length(recipList)) {
		if (is.numeric(verbose) & id %% verbose == 0) { cat(paste(id, ' ', sep='')) }
		
		this = recipList[[id]];
		# get burtoni protein ids from reciprocal blastp for current blastx hit
		abProtein = unique(grep('^XP', unlist(strsplit(this[, 2], '|', fixed=T)), value=T));	# careful of col to split on
		
		# check if more than one burtoni protein id
		if (length(abProtein) > 1) { stop(paste('Check ', names(rxs)[id], sep='')) }
		
		# find row for protein id in burtoni lookup table
		row = which(ablookup$protein == abProtein);
		
		# check whether protein id is in ablookup, not sure why but some aren't
		if (length(row) == 0) {
			# if protein id is missing from ablookup fill row with NAs
			checkRecip[id, ] = c(rep(NA, ncol(checkRecip)-3), abProtein, NA, NA);	# careful of col nums
		} else {
			# otherwise add ablookup info to row
			checkRecip[id, 1:ncol(ablookup)] = ablookup[row,];
			
			# get the original blastx results for this ab gene
			abgene = checkRecip$gene[id];
			oBlastxHit = abBlastxList[names(abBlastxList) == abgene][[1]][, 3];	# careful of col to pull hit from 
			
			# check if reciprocal blastp matched original blastx
			if (rownames(checkRecip)[id] %in% oBlastxHit) {
				checkRecip$recipMatch[id] = TRUE;
			} else {
				checkRecip$recipMatch[id] = FALSE;
			}
			
			checkRecip$oBlastxHits[id] = paste(unique(oBlastxHit), collapse=',');
		}
	}
	return(checkRecip);
}


.convertMultiSpeciesENStoHuman = function (multiSpeciesENSvec, speciesMarts, attributes, filters, spSplit=NULL) {
	speciesTriplets = unique(substr(multiSpeciesENSvec, 4, 6));
	if (!all(speciesTriplets %in% names(speciesMarts))) {
		stop('All species in ENS ids not represented in speciesMarts');
	}
	hsENS = list()
	for (species in speciesTriplets) {
		print(species);
		spGenesInds = which(grepl(species, multiSpeciesENSvec));
		spMart = speciesMarts[[match(species, names(speciesMarts))]];
		hsENS[[species]] = getBM(attributes=attributes, filters=filters, values=multiSpeciesENSvec[spGenesInds], mart=spMart);
		if (is.numeric(spSplit)) {
			hsENS[[species]] = split(hsENS[[species]], hsENS[[species]][,spSplit]);
		}
	}
	return(hsENS);
}






#############################################################


.addBiomaRtHitsToSplitBlastxResults = function (hitList, fromCol=3, char1=4, char2=6, attributes, filters, speciesMarts, verbose=NULL) {
	orthos = hitList;
	for (g in 1:length(hitList)) {
		if (is.numeric(verbose) & g %% verbose == 0) { print(g) }
		gene = hitList[[g]]; 
		speciesTriplets = substr(gene[,fromCol], char1, char2);
		numSpecies = length(unique(speciesTriplets));
		values = unique(gene[,fromCol]);
		if (numSpecies == 1) {
			martSpecies = speciesMarts[[match(unique(speciesTriplets), names(speciesMarts))]];
			tmp = getBM(attributes=attributes, filters=filters, values=values, mart=martSpecies);
		} else {
			tmp = list();
			for (s in 1:numSpecies) {
				martSpecies = speciesMarts[[match(unique(speciesTriplets)[s], names(speciesMarts))]];
				values2 = values[grepl(unique(speciesTriplets)[s], values)];
				tmp[[s]] = getBM(attributes=attributes, filters=filters, values=values2, mart=martSpecies);
			}
		}
		orthos[[g]] = list(orthos[[g]], tmp);
	}
	return(orthos);
}

tmp = .addBiomaRtHitsToSplitBlastxResults(hitList=xs[1:100], 
										  attributes=attributes, 
										  filters=filters, 
										  speciesMarts=speciesMarts, 
										  verbose=10
										  );
										  
for (g in 1:length(tmp)) {
	gene = tmp[[g]];
	if (!is.data.frame(gene[[2]])) {
		print(tmp[g])
	}
}; rm(g, gene)